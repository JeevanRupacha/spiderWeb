<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    


    <div class="result-component">
        <h3>{{title}}</h3>
        <a href="{{}}">{{links title}}</a>

        <div class="content">
            <div class="devsite-article-body clearfix devsite-no-page-title">
<h1 data-text="Create a List with RecyclerView 

  Part of Android Jetpack." id="create-a-list-with-recyclerview-part-of-android-jetpack." tabindex="0">Create a List with RecyclerView 

  <span class="dac-jetpack"><span>Part of <a href="/jetpack">Android Jetpack</a>.</span></span></h1>
<p>If your app needs to display a scrolling list of elements based on large data sets (or
data that frequently changes), you should use <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code>
as described on this page.
</p>
<p class="note"><b>Tip:</b> Start with some template code in Android Studio
by clicking <b>File &gt; New &gt; Fragment &gt; Fragment (List)</b>. Then simply <a href="/training/basics/fragments/creating#AddInLayout">add the fragment
to your activity layout</a>.</p>
<div class="cols">
<div class="col-1of2" style="width:260px">
<img src="/design/material/images/list_mail.png" width="250"/>
<p class="img-caption"><b>Figure 1.</b> A list using <code dir="ltr" translate="no">RecyclerView</code></p>
</div>
<div class="col-1of2" style="max-width:260px">
<img src="/design/material/images/card_travel.png" width="250"/>
<p class="img-caption"><b>Figure 2.</b> A list also using <code dir="ltr" translate="no">CardView</code></p>
</div>
</div>
<p>If you'd like to create a list with cards, as shown in figure 2, also use the
<code dir="ltr" translate="no"><a href="/reference/androidx/cardview/widget/CardView">CardView</a></code> widget as described in
<a href="/guide/topics/ui/layout/cardview">Create a Card-based Layout</a>.</p>
<p>If you'd like to see some sample code for <code dir="ltr" translate="no">RecyclerView</code>, check out the
RecyclerView Sample App <a class="external-link" href="https://github.com/android/views-widgets-samples/tree/master/RecyclerView">Java</a> | <a class="external-link" href="https://github.com/android/views-widgets-samples/tree/master/RecyclerViewKotlin">Kotlin</a>.</p>
<h2 data-text="RecyclerView overview" id="structure" tabindex="0">RecyclerView overview</h2>
<p>The <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> widget is a more advanced and flexible
version of <code dir="ltr" translate="no"><a href="/reference/android/widget/ListView">ListView</a></code>.</p>
<p>In the <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> model, several
different components work together to display your data.
The overall container for your user interface is a <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> object that you add to your layout. The <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> fills itself with views provided by a
<em>layout manager</em> that you provide. You can use one of our standard layout managers (such as
<code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/LinearLayoutManager">LinearLayoutManager</a></code> or <code dir="ltr" translate="no"><a href="/reference/androidx/gridlayout/widget/GridLayoutManager">GridLayoutManager</a></code>), or implement your own.
</p>
<p>
The views in the list are represented by <em>view holder</em> objects. These objects
are instances of a class you define by extending <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.ViewHolder">RecyclerView.ViewHolder</a></code>. Each view holder is in
charge of displaying a single item with a view. For example, if your list
shows music collection, each view holder might represent a single album.
The <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> creates only as many
view holders as are needed to display the on-screen portion of the dynamic
content, plus a few extra. As the user scrolls through the list, the <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> takes the off-screen views and rebinds
them to the data which is scrolling onto the screen.
</p>
<p>
The view holder objects are managed by an <em>adapter</em>, which you create by
extending <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter">RecyclerView.Adapter</a></code>.
The adapter creates view holders as needed. The adapter also binds the
view holders to their data. It does this by assigning the view holder to a
position, and calling the adapter's <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter#onBindViewHolder(VH, int)">onBindViewHolder()</a></code> method. That method uses the
view holder's position to determine what the contents should be,
based on its list position.
</p>
<p>
This <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> model does a lot of
optimization work so you don't have to:
</p>
<ul>
<li>
  When the list is first populated, it creates and binds some view holders on
  either side of the list. For example, if the view is displaying list positions 0
  through 9, the <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> creates and
  binds those view holders, and might also create and bind the view holder for
  position 10. That way, if the user scrolls the list, the next element is ready
  to display.
  </li>
<li>
  As the user scrolls the list, the <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> creates new view holders as necessary.
  It also saves the view holders which have scrolled off-screen, so they can be
  reused. If the user switches the direction they were scrolling, the view
  holders which were scrolled off the screen can be brought right back. On the
  other hand, if the user keeps scrolling in the same direction, the view
  holders   which have been off-screen the longest can be re-bound to new data.
  The view   holder does not need to be created or have its view inflated;
  instead, the app   just updates the view's contents to match the new item it
  was bound to.
  </li>
<li>
  When the displayed items change, you can notify the adapter by calling an
  appropriate <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter#notifyItemChanged(int)">RecyclerView.Adapter.notify…()</a></code> method. The adapter's built-in code then
  rebinds just the affected items.
  </li>
</ul>
<h2 data-text="Add the support library" id="add-support-library" tabindex="0">Add the support library</h2>
<p>To access the <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> widget, you need to add the
<a href="/tools/support-library/features#v7">v7 Support
Libraries</a> to your project as follows:
  </p>
<ol>
<li>Open the <code dir="ltr" translate="no">build.gradle</code> file for your app module.</li>
<li>Add the support library to the <code dir="ltr" translate="no">dependencies</code> section.
<pre class="prettyprint lang-groovy" dir="ltr" translate="no">
dependencies {
    implementation 'com.android.support:recyclerview-v7:28.0.0'
}
</pre>
</li>
</ol>
<h2 data-text="Add RecyclerView to your layout" id="workflow" tabindex="0">Add RecyclerView to your layout</h2>
<p>Now you can add the <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> to your
layout file. For example, the following layout uses <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code>
as the only view for the whole layout:
</p>
<pre class="prettyprint lang-xml" dir="ltr" translate="no">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!-- A RecyclerView with some commonly used attributes --&gt;
&lt;android.support.v7.widget.RecyclerView
    android:id="@+id/my_recycler_view"
    android:scrollbars="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent"/&gt;
</pre>
<p>Once you have added a <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> widget to your layout,
obtain a handle to the object, connect it to a layout manager, and attach an adapter for the data
to be displayed:</p>
<div>
<div class="ds-selector-tabs"><section><h3 data-text="Kotlin" id="kotlin" tabindex="0">Kotlin</h3>
<pre class="prettyprint lang-kotlin" dir="ltr" translate="no">
class MyActivity : Activity() {
    private lateinit var recyclerView: RecyclerView
    private lateinit var viewAdapter: RecyclerView.Adapter&lt;*&gt;
    private lateinit var viewManager: RecyclerView.LayoutManager

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.my_activity)

        viewManager = LinearLayoutManager(this)
        viewAdapter = MyAdapter(myDataset)

        recyclerView = findViewById&lt;RecyclerView&gt;(R.id.my_recycler_view).apply {
            // use this setting to improve performance if you know that changes
            // in content do not change the layout size of the RecyclerView
            setHasFixedSize(true)

            // use a linear layout manager
            layoutManager = viewManager

            // specify an viewAdapter (see also next example)
            adapter = viewAdapter

        }
    }
    // ...
}
</pre>
</section><section><h3 data-text="Java" id="java" tabindex="0">Java</h3>
<pre class="prettyprint lang-java" dir="ltr" translate="no">
public class MyActivity extends Activity {
    private RecyclerView recyclerView;
    private RecyclerView.Adapter mAdapter;
    private RecyclerView.LayoutManager layoutManager;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.my_activity);
        recyclerView = (RecyclerView) findViewById(R.id.my_recycler_view);

        // use this setting to improve performance if you know that changes
        // in content do not change the layout size of the RecyclerView
        recyclerView.setHasFixedSize(true);

        // use a linear layout manager
        layoutManager = new LinearLayoutManager(this);
        recyclerView.setLayoutManager(layoutManager);

        // specify an adapter (see also next example)
        mAdapter = new MyAdapter(myDataset);
        recyclerView.setAdapter(mAdapter);
    }
    // ...
}
</pre>
</section></div>
</div>
<p class="note"><strong>Note:</strong> With Android Studio 3.6 and higher, the
<a href="/topic/libraries/view-binding">view binding</a> feature can replace
<code dir="ltr" translate="no">findViewById()</code> calls and provides compile-time type safety for
code that interacts with views. Consider using view binding instead of
<code dir="ltr" translate="no">findViewById()</code>.</p>
<h2 data-text="Add a list adapter" id="Adapter" tabindex="0">Add a list adapter</h2>
<p>To feed all your data to the list, you must extend the <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter">RecyclerView.Adapter</a></code> class. This object creates views for items, and
replaces the content of some of the views with new data items when the original item is no longer
visible.</p>
<p>The following code example shows a simple implementation for a data set that consists
of an array of strings displayed using <code dir="ltr" translate="no"><a href="/reference/android/widget/TextView">TextView</a></code> widgets:
</p>
<div>
<div class="ds-selector-tabs"><section><h3 data-text="Kotlin" id="kotlin" tabindex="0">Kotlin</h3>
<pre class="prettyprint lang-kotlin" dir="ltr" translate="no">
class MyAdapter(private val myDataset: Array&lt;String&gt;) :
        RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt;() {

    // Provide a reference to the views for each data item
    // Complex data items may need more than one view per item, and
    // you provide access to all the views for a data item in a view holder.
    // Each data item is just a string in this case that is shown in a TextView.
    class MyViewHolder(val textView: TextView) : RecyclerView.ViewHolder(textView)


    // Create new views (invoked by the layout manager)
    override fun onCreateViewHolder(parent: ViewGroup,
                                    viewType: Int): MyAdapter.MyViewHolder {
        // create a new view
        val textView = LayoutInflater.from(parent.context)
                .inflate(R.layout.my_text_view, parent, false) as TextView
        // set the view's size, margins, paddings and layout parameters
        ...
        return MyViewHolder(textView)
    }

    // Replace the contents of a view (invoked by the layout manager)
    override fun onBindViewHolder(holder: MyViewHolder, position: Int) {
        // - get element from your dataset at this position
        // - replace the contents of the view with that element
        holder.textView.text = myDataset[position]
    }

    // Return the size of your dataset (invoked by the layout manager)
    override fun getItemCount() = myDataset.size
}
</pre>
</section><section><h3 data-text="Java" id="java" tabindex="0">Java</h3>
<pre class="prettyprint lang-java" dir="ltr" translate="no">
public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; {
    private String[] mDataset;

    // Provide a reference to the views for each data item
    // Complex data items may need more than one view per item, and
    // you provide access to all the views for a data item in a view holder
    public static class MyViewHolder extends RecyclerView.ViewHolder {
        // each data item is just a string in this case
        public TextView textView;
        public MyViewHolder(TextView v) {
            super(v);
            textView = v;
        }
    }

    // Provide a suitable constructor (depends on the kind of dataset)
    public MyAdapter(String[] myDataset) {
        mDataset = myDataset;
    }

    // Create new views (invoked by the layout manager)
    @Override
    public MyAdapter.MyViewHolder onCreateViewHolder(ViewGroup parent,
                                                   int viewType) {
        // create a new view
        TextView v = (TextView) LayoutInflater.from(parent.getContext())
                .inflate(R.layout.my_text_view, parent, false);
        ...
        MyViewHolder vh = new MyViewHolder(v);
        return vh;
    }

    // Replace the contents of a view (invoked by the layout manager)
    @Override
    public void onBindViewHolder(MyViewHolder holder, int position) {
        // - get element from your dataset at this position
        // - replace the contents of the view with that element
        holder.textView.setText(mDataset[position]);

    }

    // Return the size of your dataset (invoked by the layout manager)
    @Override
    public int getItemCount() {
        return mDataset.length;
    }
}
</pre>
</section></div>
</div>
<p>
  The layout manager calls the adapter's <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter#onCreateViewHolder(android.view.ViewGroup, int)">onCreateViewHolder()</a></code> method. That method needs to construct a <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.ViewHolder">RecyclerView.ViewHolder</a></code>
  and set the view it uses to display its contents. The type of the
  ViewHolder must match the type declared in the Adapter class signature. Typically, it
  would set the view by inflating an XML layout file. Because the view holder
  is not yet assigned to any particular data, the method does not actually
  set the view's contents.
</p>
<p>
  The layout manager then binds the view holder to its data. It
  does this by calling the adapter's <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter#onBindViewHolder(VH, int)">onBindViewHolder()</a></code> method, and passing the view holder's position in the
  <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code>. The <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter#onBindViewHolder(VH, int)">onBindViewHolder()</a></code> method needs to fetch the appropriate data, and use it
  to fill in the view holder's layout. For example, if the <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> is displaying a list of names, the
  method might find the appropriate name in the list, and fill in the view
  holder's <code dir="ltr" translate="no"><a href="/reference/android/widget/TextView">TextView</a></code> widget.
</p>
<p>
If the list needs an update, call a notification method on the <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter">RecyclerView.Adapter</a></code> object, such as
<code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter#notifyItemChanged(int)">notifyItemChanged()</a></code>. The layout manager then rebinds any
affected view holders, allowing their data to be updated.
</p>
<p class="note"><b>Tip:</b>
  You might find the <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/ListAdapter">ListAdapter</a></code> class
  useful for determining which items in your list need to be updated when the list changes.
</p>
<h2 data-text="Customize your RecyclerView" id="customizing" tabindex="0">Customize your RecyclerView</h2>
<p>
You can customize the <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> objects to
meet your specific needs. The standard classes provide all the functionality
that most developers will need; in many cases, the only customization you need
to do is design the view for each view holder and write the code to update
those views with the appropriate data. However, if your app has specific
requirements, you can modify the standard behavior in a number of ways. The
following sections describe some of the other common customizations.
</p>
<h3 data-text="Modifying the layout" id="modifying-layout" tabindex="0">Modifying the layout</h3>
<p>
The <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> uses a layout manager to
position the individual items on the screen and determine when to reuse item views that are no
longer visible to the user. To reuse (or <em>recycle</em>) a view, a layout manager may ask the
adapter to replace the contents of the view with a different element from the dataset. Recycling
views in this manner improves performance by avoiding the creation of unnecessary views or
performing expensive <code dir="ltr" translate="no"><a href="/reference/android/app/Activity#findViewById(int)">findViewById()</a></code> lookups. The Android
Support Library includes three standard layout managers, each of which offers many customization
options:
</p>
<ul>
<li><code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/LinearLayoutManager">LinearLayoutManager</a></code> arranges the items in
    a one-dimensional list. Using a <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> with <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/LinearLayoutManager">LinearLayoutManager</a></code> provides functionality like
    the older <code dir="ltr" translate="no"><a href="/reference/android/widget/ListView">ListView</a></code> layout.</li>
<li><code dir="ltr" translate="no"><a href="/reference/androidx/gridlayout/widget/GridLayoutManager">GridLayoutManager</a></code> arranges the items in a
    two-dimensional grid, like the squares on a checkerboard. Using a <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> with <code dir="ltr" translate="no"><a href="/reference/androidx/gridlayout/widget/GridLayoutManager">GridLayoutManager</a></code> provides functionality like
    the older <code dir="ltr" translate="no"><a href="/reference/android/widget/GridView">GridView</a></code> layout.</li>
<li><code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/StaggeredGridLayoutManager">StaggeredGridLayoutManager</a></code> arranges the
    items in a two-dimensional grid, with each column slightly offset from the
    one before, like the stars in an American flag.</li>
</ul>
<p>
If none of these layout managers suits your needs, you can create your own by
extending the <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.LayoutManager">RecyclerView.LayoutManager</a></code>
abstract class.
</p>
<h2 data-text="Add item animations" id="animations" tabindex="0">Add item animations</h2>
<p>
Whenever an item changes, the <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code>
uses an <em>animator</em> to change its appearance. This animator is an object that
extends the abstract <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.ItemAnimator">RecyclerView.ItemAnimator</a></code> class. By default, the
<code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> uses <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/DefaultItemAnimator">DefaultItemAnimator</a></code> to
provide the animation. If you want to provide custom animations, you can define
your own animator object by extending <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.ItemAnimator">RecyclerView.ItemAnimator</a></code>.
</p>
<h2 data-text="Enable list-item selection" id="select" tabindex="0">Enable list-item selection</h2>
<p>The
  <a href="/reference/androidx/recyclerview/selection/package-summary"><code dir="ltr" translate="no">recyclerview-selection</code></a>
  library enables users to select items in
  <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> list using touch or mouse input.
  You retain control over the visual presentation of a selected item. You
  can also retain control over policies controlling selection behavior, such as
  items that can be eligible for selection, and how many items can be selected.
</p>
<p>To add selection support to a <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code>
  instance, follow these steps:
</p>
<ol type="1">
<li>Determine which selection key type to use, then build a
    <a href="/reference/androidx/recyclerview/selection/ItemKeyProvider"><code dir="ltr" translate="no">ItemKeyProvider</code></a>.
  <p>
  There are three key types that you can use to identify selected items:
  <code dir="ltr" translate="no"><a href="/reference/android/os/Parcelable">Parcelable</a></code> (and all subclasses like
  <code dir="ltr" translate="no"><a href="/reference/android/net/Uri">Uri</a></code>), <code dir="ltr" translate="no"><a href="/reference/java/lang/String">String</a></code>, and <code dir="ltr" translate="no"><a href="/reference/java/lang/Long">Long</a></code>.
  For detailed information about selection-key types, see
  <a href="/reference/androidx/recyclerview/selection/SelectionTracker.Builder"><code dir="ltr" translate="no">SelectionTracker.Builder</code></a>.
  </p>
</li>
<li>Implement <a href="/reference/androidx/recyclerview/selection/ItemDetailsLookup"><code dir="ltr" translate="no">ItemDetailsLookup</code></a>.</li>
<p>
<a href="/reference/androidx/recyclerview/selection/ItemDetailsLookup"><code dir="ltr" translate="no">ItemDetailsLookup</code></a>
    enables the selection library to access information about
    <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> items given a
    <code dir="ltr" translate="no"><a href="/reference/android/view/MotionEvent">MotionEvent</a></code>.
    It is effectively a factory for
    <a href="/reference/androidx/recyclerview/selection/ItemDetailsLookup.ItemDetails"><code dir="ltr" translate="no">ItemDetails</code></a>
    instances that are backed up by (or extracted from) a
    <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.ViewHolder">RecyclerView.ViewHolder</a></code> instance.
   </p><li>Update item <code dir="ltr" translate="no"><a href="/reference/android/view/View">Views</a></code> in
     <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> to reflect that the user has
     selected or unselected it.
  <p>
   The selection library does not provide a default visual decoration for the
    selected items. You must provide this when you implement
    <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter#onBindViewHolder(VH, int)">onBindViewHolder()</a></code>.
    The recommended approach is as follows:
   </p><ul>
<li>In
       <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter#onBindViewHolder(VH, int)">onBindViewHolder()</a></code>,
       call
       <code dir="ltr" translate="no"><a href="/reference/android/view/View#setActivated(boolean)">setActivated()</a></code>
       (not <code dir="ltr" translate="no"><a href="/reference/android/view/View#setSelected(boolean)">setSelected()</a></code>)
       on the <code dir="ltr" translate="no"><a href="/reference/android/view/View">View</a></code> object with <code dir="ltr" translate="no">true</code> or
       <code dir="ltr" translate="no">false</code> (depending on if the item is selected).</li>
<li>Update the styling of the view to represent the activated status. We
       recommend you use a
       <a href="/guide/topics/resources/color-list-resource">color state list resource</a>
       to configure the styling.</li>
</ul>
</li>
<li>Use <code dir="ltr" translate="no"><a href="/reference/androidx/appcompat/view/ActionMode">ActionMode</a></code> to provide the user with
    tools to perform an action on the selection.</li>
<p>
    Register a <a href="/reference/androidx/recyclerview/selection/SelectionTracker.SelectionObserver"><code dir="ltr" translate="no">SelectionTracker.SelectionObserver</code></a>
    to be notified when selection changes. When a selection is first created,
    start <code dir="ltr" translate="no"><a href="/reference/androidx/appcompat/view/ActionMode">ActionMode</a></code> to represent this to the
    user, and provide selection-specific actions. For example, you may add a
    delete button to the <code dir="ltr" translate="no"><a href="/reference/androidx/appcompat/view/ActionMode">ActionMode</a></code> bar, and
    connect the back arrow on the bar to clear the selection. When the selection
    becomes empty (if the user cleared the selection the last time), don't
    forget to terminate action mode.
  </p>
<li>Perform any interpreted secondary actions</li>
<p>
    At the end of the event processing pipeline, the library may determine that
    the user is attempting to activate an item by tapping it, or is attempting
    to drag and drop an item or set of selected items. React to these
    interpretations by registering the appropriate listener. For more
    information, see
    <a href="/reference/androidx/recyclerview/selection/SelectionTracker.Builder"><code dir="ltr" translate="no">SelectionTracker.Builder</code></a>.
  </p>
<li>Assemble everything with
    <a href="/reference/androidx/recyclerview/selection/SelectionTracker.Builder"><code dir="ltr" translate="no">SelectionTracker.Builder</code></a></li>
<p>
    The following example shows how to put these pieces together by using the
    <code dir="ltr" translate="no"><a href="/reference/java/lang/Long">Long</a></code> selection key:
  </p>
<div>
<div class="ds-selector-tabs"><section><h3 data-text="Kotlin" id="kotlin" tabindex="0">Kotlin</h3>
<pre class="prettyprint lang-kotlin" dir="ltr" translate="no">
var tracker = SelectionTracker.Builder(
    "my-selection-id",
    recyclerView,
    StableIdKeyProvider(recyclerView),
    MyDetailsLookup(recyclerView),
    StorageStrategy.createLongStorage())
        .withOnItemActivatedListener(myItemActivatedListener)
        .build()
</pre>
</section><section><h3 data-text="Java" id="java" tabindex="0">Java</h3>
<pre class="prettyprint lang-java" dir="ltr" translate="no">
SelectionTracker tracker = new SelectionTracker.Builder&lt;&gt;(
        "my-selection-id",
        recyclerView,
        new StableIdKeyProvider(recyclerView),
        new MyDetailsLookup(recyclerView),
        StorageStrategy.createLongStorage())
        .withOnItemActivatedListener(myItemActivatedListener)
        .build();
</pre>
</section></div>
</div>
<p>
  In order to build a
  <a href="/reference/androidx/recyclerview/selection/SelectionTracker"><code dir="ltr" translate="no">SelectionTracker</code></a>
  instance, your app must supply the same
  <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter">RecyclerView.Adapter</a></code> that you used to
  initialize <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code>
  to
  <a href="/reference/androidx/recyclerview/selection/SelectionTracker.Builder"><code dir="ltr" translate="no">SelectionTracker.Builder</code></a>.
  For this reason, you will most likely need to inject the
  <a href="/reference/androidx/recyclerview/selection/SelectionTracker"><code dir="ltr" translate="no">SelectionTracker</code></a>
  instance, once created, into your
  <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter">RecyclerView.Adapter</a></code> after the
  <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter">RecyclerView.Adapter</a></code>
  is
  created. Otherwise, you won't be able to check an item's selected status from
  the
  <a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter#onBindViewHolder(VH, int)"><code dir="ltr" translate="no">onBindViewHolder()</code></a>
  method.
</p>
<li>Include selection in the <a href="/guide/components/activities/activity-lifecycle">activity lifecycle</a>
    events.</li>
<p>In order to preserve selection state across the
    <a href="/guide/components/activities/activity-lifecycle">activity lifecycle</a>
    events, your app must call the selection tracker's
    <a href="/reference/androidx/recyclerview/selection/SelectionTracker#onSaveInstanceState(android.os.Bundle)"><code dir="ltr" translate="no">onSaveInstanceState()</code></a>
    and
    <a href="/reference/androidx/recyclerview/selection/SelectionTracker#onRestoreInstanceState(android.os.Bundle)"><code dir="ltr" translate="no">onRestoreInstanceState()</code></a>
    methods from the activity's
    <code dir="ltr" translate="no"><a href="/reference/android/app/Activity#onSaveInstanceState(android.os.Bundle)">onSaveInstanceState()</a></code> and
    <code dir="ltr" translate="no"><a href="/reference/android/app/Activity#onRestoreInstanceState(android.os.Bundle)">onRestoreInstanceState()</a></code>
    methods respectively. Your app must also supply a unique selection ID to the
    <a href="/reference/androidx/recyclerview/selection/SelectionTracker.Builder"><code dir="ltr" translate="no">SelectionTracker.Builder</code></a>
    constructor. This ID is required because an activity or a fragment may have
    more than one distinct, selectable list, all of which need to be persisted
    in their saved state.
</p>
<h2 data-text="Additional resources" id="additional-resources" tabindex="0">Additional resources</h2>
<p><code dir="ltr" translate="no">RecyclerView</code> is
used in the <a href="https://github.com/googlesamples/android-sunflower">Sunflower</a> demo app.</p>
</ol></div>
        </div>
    </div>

    <div class="result-component">
        <h3>{{title}}</h3>
        <a href="{{}}">{{links title}}</a>

        <div class="content">this is content section
        lorem30kjffjfkdhjkdhfjhgkjdf
        
        <pre>
            hthjtj jhgh shj
            sjdfhjd         ejfhjfhkjfhksjksjdhfkhdfskjfhjkfsrgegrgdfgdfgdgfdggfdgfgdggdg gsdgsgdsgdgsdgsgsgdgsgdsgs jgkshjkk
        </pre>

        <p>hjrgfshjjgfsjfjdgshgfdshgfhshjdghhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhdffffffffffdddddddddddddddddddddd</p>
        </div>
    </div>

    <div class="result-component">
        <h3>{{title}}</h3>
        <a href="{{}}">{{links title}}</a>

        <div class="content">this is content section
        lorem30kjffjfkdhjkdhfjhgkjdf
        
        <pre>
            hthjtj jhgh shj
            sjdfhjd         ejfhjfhkjfhksjksjdhfkhdfskjfhjkfsrgegrgdfgdfgdgfdggfdgfgdggdg gsdgsgdsgdgsdgsgsgdgsgdsgs jgkshjkk
        </pre>

        <p>hjrgfshjjgfsjfjdgshgfdshgfhshjdghhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhdffffffffffdddddddddddddddddddddd</p>
        </div>
    </div>

    <div class="result-component">
        <h3>{{title}}</h3>
        <a href="{{}}">{{links title}}</a>

        <div class="content">
            <div class="devsite-article-body clearfix devsite-no-page-title">
<h1 data-text="Create a List with RecyclerView 

  Part of Android Jetpack." id="create-a-list-with-recyclerview-part-of-android-jetpack." tabindex="0">Create a List with RecyclerView 

  <span class="dac-jetpack"><span>Part of <a href="/jetpack">Android Jetpack</a>.</span></span></h1>
<p>If your app needs to display a scrolling list of elements based on large data sets (or
data that frequently changes), you should use <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code>
as described on this page.
</p>
<p class="note"><b>Tip:</b> Start with some template code in Android Studio
by clicking <b>File &gt; New &gt; Fragment &gt; Fragment (List)</b>. Then simply <a href="/training/basics/fragments/creating#AddInLayout">add the fragment
to your activity layout</a>.</p>
<div class="cols">
<div class="col-1of2" style="width:260px">
<img src="/design/material/images/list_mail.png" width="250"/>
<p class="img-caption"><b>Figure 1.</b> A list using <code dir="ltr" translate="no">RecyclerView</code></p>
</div>
<div class="col-1of2" style="max-width:260px">
<img src="/design/material/images/card_travel.png" width="250"/>
<p class="img-caption"><b>Figure 2.</b> A list also using <code dir="ltr" translate="no">CardView</code></p>
</div>
</div>
<p>If you'd like to create a list with cards, as shown in figure 2, also use the
<code dir="ltr" translate="no"><a href="/reference/androidx/cardview/widget/CardView">CardView</a></code> widget as described in
<a href="/guide/topics/ui/layout/cardview">Create a Card-based Layout</a>.</p>
<p>If you'd like to see some sample code for <code dir="ltr" translate="no">RecyclerView</code>, check out the
RecyclerView Sample App <a class="external-link" href="https://github.com/android/views-widgets-samples/tree/master/RecyclerView">Java</a> | <a class="external-link" href="https://github.com/android/views-widgets-samples/tree/master/RecyclerViewKotlin">Kotlin</a>.</p>
<h2 data-text="RecyclerView overview" id="structure" tabindex="0">RecyclerView overview</h2>
<p>The <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> widget is a more advanced and flexible
version of <code dir="ltr" translate="no"><a href="/reference/android/widget/ListView">ListView</a></code>.</p>
<p>In the <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> model, several
different components work together to display your data.
The overall container for your user interface is a <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> object that you add to your layout. The <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> fills itself with views provided by a
<em>layout manager</em> that you provide. You can use one of our standard layout managers (such as
<code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/LinearLayoutManager">LinearLayoutManager</a></code> or <code dir="ltr" translate="no"><a href="/reference/androidx/gridlayout/widget/GridLayoutManager">GridLayoutManager</a></code>), or implement your own.
</p>
<p>
The views in the list are represented by <em>view holder</em> objects. These objects
are instances of a class you define by extending <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.ViewHolder">RecyclerView.ViewHolder</a></code>. Each view holder is in
charge of displaying a single item with a view. For example, if your list
shows music collection, each view holder might represent a single album.
The <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> creates only as many
view holders as are needed to display the on-screen portion of the dynamic
content, plus a few extra. As the user scrolls through the list, the <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> takes the off-screen views and rebinds
them to the data which is scrolling onto the screen.
</p>
<p>
The view holder objects are managed by an <em>adapter</em>, which you create by
extending <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter">RecyclerView.Adapter</a></code>.
The adapter creates view holders as needed. The adapter also binds the
view holders to their data. It does this by assigning the view holder to a
position, and calling the adapter's <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter#onBindViewHolder(VH, int)">onBindViewHolder()</a></code> method. That method uses the
view holder's position to determine what the contents should be,
based on its list position.
</p>
<p>
This <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> model does a lot of
optimization work so you don't have to:
</p>
<ul>
<li>
  When the list is first populated, it creates and binds some view holders on
  either side of the list. For example, if the view is displaying list positions 0
  through 9, the <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> creates and
  binds those view holders, and might also create and bind the view holder for
  position 10. That way, if the user scrolls the list, the next element is ready
  to display.
  </li>
<li>
  As the user scrolls the list, the <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> creates new view holders as necessary.
  It also saves the view holders which have scrolled off-screen, so they can be
  reused. If the user switches the direction they were scrolling, the view
  holders which were scrolled off the screen can be brought right back. On the
  other hand, if the user keeps scrolling in the same direction, the view
  holders   which have been off-screen the longest can be re-bound to new data.
  The view   holder does not need to be created or have its view inflated;
  instead, the app   just updates the view's contents to match the new item it
  was bound to.
  </li>
<li>
  When the displayed items change, you can notify the adapter by calling an
  appropriate <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter#notifyItemChanged(int)">RecyclerView.Adapter.notify…()</a></code> method. The adapter's built-in code then
  rebinds just the affected items.
  </li>
</ul>
<h2 data-text="Add the support library" id="add-support-library" tabindex="0">Add the support library</h2>
<p>To access the <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> widget, you need to add the
<a href="/tools/support-library/features#v7">v7 Support
Libraries</a> to your project as follows:
  </p>
<ol>
<li>Open the <code dir="ltr" translate="no">build.gradle</code> file for your app module.</li>
<li>Add the support library to the <code dir="ltr" translate="no">dependencies</code> section.
<pre class="prettyprint lang-groovy" dir="ltr" translate="no">
dependencies {
    implementation 'com.android.support:recyclerview-v7:28.0.0'
}
</pre>
</li>
</ol>
<h2 data-text="Add RecyclerView to your layout" id="workflow" tabindex="0">Add RecyclerView to your layout</h2>
<p>Now you can add the <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> to your
layout file. For example, the following layout uses <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code>
as the only view for the whole layout:
</p>
<pre class="prettyprint lang-xml" dir="ltr" translate="no">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!-- A RecyclerView with some commonly used attributes --&gt;
&lt;android.support.v7.widget.RecyclerView
    android:id="@+id/my_recycler_view"
    android:scrollbars="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent"/&gt;
</pre>
<p>Once you have added a <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> widget to your layout,
obtain a handle to the object, connect it to a layout manager, and attach an adapter for the data
to be displayed:</p>
<div>
<div class="ds-selector-tabs"><section><h3 data-text="Kotlin" id="kotlin" tabindex="0">Kotlin</h3>
<pre class="prettyprint lang-kotlin" dir="ltr" translate="no">
class MyActivity : Activity() {
    private lateinit var recyclerView: RecyclerView
    private lateinit var viewAdapter: RecyclerView.Adapter&lt;*&gt;
    private lateinit var viewManager: RecyclerView.LayoutManager

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.my_activity)

        viewManager = LinearLayoutManager(this)
        viewAdapter = MyAdapter(myDataset)

        recyclerView = findViewById&lt;RecyclerView&gt;(R.id.my_recycler_view).apply {
            // use this setting to improve performance if you know that changes
            // in content do not change the layout size of the RecyclerView
            setHasFixedSize(true)

            // use a linear layout manager
            layoutManager = viewManager

            // specify an viewAdapter (see also next example)
            adapter = viewAdapter

        }
    }
    // ...
}
</pre>
</section><section><h3 data-text="Java" id="java" tabindex="0">Java</h3>
<pre class="prettyprint lang-java" dir="ltr" translate="no">
public class MyActivity extends Activity {
    private RecyclerView recyclerView;
    private RecyclerView.Adapter mAdapter;
    private RecyclerView.LayoutManager layoutManager;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.my_activity);
        recyclerView = (RecyclerView) findViewById(R.id.my_recycler_view);

        // use this setting to improve performance if you know that changes
        // in content do not change the layout size of the RecyclerView
        recyclerView.setHasFixedSize(true);

        // use a linear layout manager
        layoutManager = new LinearLayoutManager(this);
        recyclerView.setLayoutManager(layoutManager);

        // specify an adapter (see also next example)
        mAdapter = new MyAdapter(myDataset);
        recyclerView.setAdapter(mAdapter);
    }
    // ...
}
</pre>
</section></div>
</div>
<p class="note"><strong>Note:</strong> With Android Studio 3.6 and higher, the
<a href="/topic/libraries/view-binding">view binding</a> feature can replace
<code dir="ltr" translate="no">findViewById()</code> calls and provides compile-time type safety for
code that interacts with views. Consider using view binding instead of
<code dir="ltr" translate="no">findViewById()</code>.</p>
<h2 data-text="Add a list adapter" id="Adapter" tabindex="0">Add a list adapter</h2>
<p>To feed all your data to the list, you must extend the <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter">RecyclerView.Adapter</a></code> class. This object creates views for items, and
replaces the content of some of the views with new data items when the original item is no longer
visible.</p>
<p>The following code example shows a simple implementation for a data set that consists
of an array of strings displayed using <code dir="ltr" translate="no"><a href="/reference/android/widget/TextView">TextView</a></code> widgets:
</p>
<div>
<div class="ds-selector-tabs"><section><h3 data-text="Kotlin" id="kotlin" tabindex="0">Kotlin</h3>
<pre class="prettyprint lang-kotlin" dir="ltr" translate="no">
class MyAdapter(private val myDataset: Array&lt;String&gt;) :
        RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt;() {

    // Provide a reference to the views for each data item
    // Complex data items may need more than one view per item, and
    // you provide access to all the views for a data item in a view holder.
    // Each data item is just a string in this case that is shown in a TextView.
    class MyViewHolder(val textView: TextView) : RecyclerView.ViewHolder(textView)


    // Create new views (invoked by the layout manager)
    override fun onCreateViewHolder(parent: ViewGroup,
                                    viewType: Int): MyAdapter.MyViewHolder {
        // create a new view
        val textView = LayoutInflater.from(parent.context)
                .inflate(R.layout.my_text_view, parent, false) as TextView
        // set the view's size, margins, paddings and layout parameters
        ...
        return MyViewHolder(textView)
    }

    // Replace the contents of a view (invoked by the layout manager)
    override fun onBindViewHolder(holder: MyViewHolder, position: Int) {
        // - get element from your dataset at this position
        // - replace the contents of the view with that element
        holder.textView.text = myDataset[position]
    }

    // Return the size of your dataset (invoked by the layout manager)
    override fun getItemCount() = myDataset.size
}
</pre>
</section><section><h3 data-text="Java" id="java" tabindex="0">Java</h3>
<pre class="prettyprint lang-java" dir="ltr" translate="no">
public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; {
    private String[] mDataset;

    // Provide a reference to the views for each data item
    // Complex data items may need more than one view per item, and
    // you provide access to all the views for a data item in a view holder
    public static class MyViewHolder extends RecyclerView.ViewHolder {
        // each data item is just a string in this case
        public TextView textView;
        public MyViewHolder(TextView v) {
            super(v);
            textView = v;
        }
    }

    // Provide a suitable constructor (depends on the kind of dataset)
    public MyAdapter(String[] myDataset) {
        mDataset = myDataset;
    }

    // Create new views (invoked by the layout manager)
    @Override
    public MyAdapter.MyViewHolder onCreateViewHolder(ViewGroup parent,
                                                   int viewType) {
        // create a new view
        TextView v = (TextView) LayoutInflater.from(parent.getContext())
                .inflate(R.layout.my_text_view, parent, false);
        ...
        MyViewHolder vh = new MyViewHolder(v);
        return vh;
    }

    // Replace the contents of a view (invoked by the layout manager)
    @Override
    public void onBindViewHolder(MyViewHolder holder, int position) {
        // - get element from your dataset at this position
        // - replace the contents of the view with that element
        holder.textView.setText(mDataset[position]);

    }

    // Return the size of your dataset (invoked by the layout manager)
    @Override
    public int getItemCount() {
        return mDataset.length;
    }
}
</pre>
</section></div>
</div>
<p>
  The layout manager calls the adapter's <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter#onCreateViewHolder(android.view.ViewGroup, int)">onCreateViewHolder()</a></code> method. That method needs to construct a <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.ViewHolder">RecyclerView.ViewHolder</a></code>
  and set the view it uses to display its contents. The type of the
  ViewHolder must match the type declared in the Adapter class signature. Typically, it
  would set the view by inflating an XML layout file. Because the view holder
  is not yet assigned to any particular data, the method does not actually
  set the view's contents.
</p>
<p>
  The layout manager then binds the view holder to its data. It
  does this by calling the adapter's <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter#onBindViewHolder(VH, int)">onBindViewHolder()</a></code> method, and passing the view holder's position in the
  <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code>. The <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter#onBindViewHolder(VH, int)">onBindViewHolder()</a></code> method needs to fetch the appropriate data, and use it
  to fill in the view holder's layout. For example, if the <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> is displaying a list of names, the
  method might find the appropriate name in the list, and fill in the view
  holder's <code dir="ltr" translate="no"><a href="/reference/android/widget/TextView">TextView</a></code> widget.
</p>
<p>
If the list needs an update, call a notification method on the <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter">RecyclerView.Adapter</a></code> object, such as
<code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter#notifyItemChanged(int)">notifyItemChanged()</a></code>. The layout manager then rebinds any
affected view holders, allowing their data to be updated.
</p>
<p class="note"><b>Tip:</b>
  You might find the <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/ListAdapter">ListAdapter</a></code> class
  useful for determining which items in your list need to be updated when the list changes.
</p>
<h2 data-text="Customize your RecyclerView" id="customizing" tabindex="0">Customize your RecyclerView</h2>
<p>
You can customize the <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> objects to
meet your specific needs. The standard classes provide all the functionality
that most developers will need; in many cases, the only customization you need
to do is design the view for each view holder and write the code to update
those views with the appropriate data. However, if your app has specific
requirements, you can modify the standard behavior in a number of ways. The
following sections describe some of the other common customizations.
</p>
<h3 data-text="Modifying the layout" id="modifying-layout" tabindex="0">Modifying the layout</h3>
<p>
The <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> uses a layout manager to
position the individual items on the screen and determine when to reuse item views that are no
longer visible to the user. To reuse (or <em>recycle</em>) a view, a layout manager may ask the
adapter to replace the contents of the view with a different element from the dataset. Recycling
views in this manner improves performance by avoiding the creation of unnecessary views or
performing expensive <code dir="ltr" translate="no"><a href="/reference/android/app/Activity#findViewById(int)">findViewById()</a></code> lookups. The Android
Support Library includes three standard layout managers, each of which offers many customization
options:
</p>
<ul>
<li><code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/LinearLayoutManager">LinearLayoutManager</a></code> arranges the items in
    a one-dimensional list. Using a <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> with <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/LinearLayoutManager">LinearLayoutManager</a></code> provides functionality like
    the older <code dir="ltr" translate="no"><a href="/reference/android/widget/ListView">ListView</a></code> layout.</li>
<li><code dir="ltr" translate="no"><a href="/reference/androidx/gridlayout/widget/GridLayoutManager">GridLayoutManager</a></code> arranges the items in a
    two-dimensional grid, like the squares on a checkerboard. Using a <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> with <code dir="ltr" translate="no"><a href="/reference/androidx/gridlayout/widget/GridLayoutManager">GridLayoutManager</a></code> provides functionality like
    the older <code dir="ltr" translate="no"><a href="/reference/android/widget/GridView">GridView</a></code> layout.</li>
<li><code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/StaggeredGridLayoutManager">StaggeredGridLayoutManager</a></code> arranges the
    items in a two-dimensional grid, with each column slightly offset from the
    one before, like the stars in an American flag.</li>
</ul>
<p>
If none of these layout managers suits your needs, you can create your own by
extending the <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.LayoutManager">RecyclerView.LayoutManager</a></code>
abstract class.
</p>
<h2 data-text="Add item animations" id="animations" tabindex="0">Add item animations</h2>
<p>
Whenever an item changes, the <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code>
uses an <em>animator</em> to change its appearance. This animator is an object that
extends the abstract <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.ItemAnimator">RecyclerView.ItemAnimator</a></code> class. By default, the
<code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> uses <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/DefaultItemAnimator">DefaultItemAnimator</a></code> to
provide the animation. If you want to provide custom animations, you can define
your own animator object by extending <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.ItemAnimator">RecyclerView.ItemAnimator</a></code>.
</p>
<h2 data-text="Enable list-item selection" id="select" tabindex="0">Enable list-item selection</h2>
<p>The
  <a href="/reference/androidx/recyclerview/selection/package-summary"><code dir="ltr" translate="no">recyclerview-selection</code></a>
  library enables users to select items in
  <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> list using touch or mouse input.
  You retain control over the visual presentation of a selected item. You
  can also retain control over policies controlling selection behavior, such as
  items that can be eligible for selection, and how many items can be selected.
</p>
<p>To add selection support to a <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code>
  instance, follow these steps:
</p>
<ol type="1">
<li>Determine which selection key type to use, then build a
    <a href="/reference/androidx/recyclerview/selection/ItemKeyProvider"><code dir="ltr" translate="no">ItemKeyProvider</code></a>.
  <p>
  There are three key types that you can use to identify selected items:
  <code dir="ltr" translate="no"><a href="/reference/android/os/Parcelable">Parcelable</a></code> (and all subclasses like
  <code dir="ltr" translate="no"><a href="/reference/android/net/Uri">Uri</a></code>), <code dir="ltr" translate="no"><a href="/reference/java/lang/String">String</a></code>, and <code dir="ltr" translate="no"><a href="/reference/java/lang/Long">Long</a></code>.
  For detailed information about selection-key types, see
  <a href="/reference/androidx/recyclerview/selection/SelectionTracker.Builder"><code dir="ltr" translate="no">SelectionTracker.Builder</code></a>.
  </p>
</li>
<li>Implement <a href="/reference/androidx/recyclerview/selection/ItemDetailsLookup"><code dir="ltr" translate="no">ItemDetailsLookup</code></a>.</li>
<p>
<a href="/reference/androidx/recyclerview/selection/ItemDetailsLookup"><code dir="ltr" translate="no">ItemDetailsLookup</code></a>
    enables the selection library to access information about
    <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> items given a
    <code dir="ltr" translate="no"><a href="/reference/android/view/MotionEvent">MotionEvent</a></code>.
    It is effectively a factory for
    <a href="/reference/androidx/recyclerview/selection/ItemDetailsLookup.ItemDetails"><code dir="ltr" translate="no">ItemDetails</code></a>
    instances that are backed up by (or extracted from) a
    <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.ViewHolder">RecyclerView.ViewHolder</a></code> instance.
   </p><li>Update item <code dir="ltr" translate="no"><a href="/reference/android/view/View">Views</a></code> in
     <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code> to reflect that the user has
     selected or unselected it.
  <p>
   The selection library does not provide a default visual decoration for the
    selected items. You must provide this when you implement
    <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter#onBindViewHolder(VH, int)">onBindViewHolder()</a></code>.
    The recommended approach is as follows:
   </p><ul>
<li>In
       <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter#onBindViewHolder(VH, int)">onBindViewHolder()</a></code>,
       call
       <code dir="ltr" translate="no"><a href="/reference/android/view/View#setActivated(boolean)">setActivated()</a></code>
       (not <code dir="ltr" translate="no"><a href="/reference/android/view/View#setSelected(boolean)">setSelected()</a></code>)
       on the <code dir="ltr" translate="no"><a href="/reference/android/view/View">View</a></code> object with <code dir="ltr" translate="no">true</code> or
       <code dir="ltr" translate="no">false</code> (depending on if the item is selected).</li>
<li>Update the styling of the view to represent the activated status. We
       recommend you use a
       <a href="/guide/topics/resources/color-list-resource">color state list resource</a>
       to configure the styling.</li>
</ul>
</li>
<li>Use <code dir="ltr" translate="no"><a href="/reference/androidx/appcompat/view/ActionMode">ActionMode</a></code> to provide the user with
    tools to perform an action on the selection.</li>
<p>
    Register a <a href="/reference/androidx/recyclerview/selection/SelectionTracker.SelectionObserver"><code dir="ltr" translate="no">SelectionTracker.SelectionObserver</code></a>
    to be notified when selection changes. When a selection is first created,
    start <code dir="ltr" translate="no"><a href="/reference/androidx/appcompat/view/ActionMode">ActionMode</a></code> to represent this to the
    user, and provide selection-specific actions. For example, you may add a
    delete button to the <code dir="ltr" translate="no"><a href="/reference/androidx/appcompat/view/ActionMode">ActionMode</a></code> bar, and
    connect the back arrow on the bar to clear the selection. When the selection
    becomes empty (if the user cleared the selection the last time), don't
    forget to terminate action mode.
  </p>
<li>Perform any interpreted secondary actions</li>
<p>
    At the end of the event processing pipeline, the library may determine that
    the user is attempting to activate an item by tapping it, or is attempting
    to drag and drop an item or set of selected items. React to these
    interpretations by registering the appropriate listener. For more
    information, see
    <a href="/reference/androidx/recyclerview/selection/SelectionTracker.Builder"><code dir="ltr" translate="no">SelectionTracker.Builder</code></a>.
  </p>
<li>Assemble everything with
    <a href="/reference/androidx/recyclerview/selection/SelectionTracker.Builder"><code dir="ltr" translate="no">SelectionTracker.Builder</code></a></li>
<p>
    The following example shows how to put these pieces together by using the
    <code dir="ltr" translate="no"><a href="/reference/java/lang/Long">Long</a></code> selection key:
  </p>
<div>
<div class="ds-selector-tabs"><section><h3 data-text="Kotlin" id="kotlin" tabindex="0">Kotlin</h3>
<pre class="prettyprint lang-kotlin" dir="ltr" translate="no">
var tracker = SelectionTracker.Builder(
    "my-selection-id",
    recyclerView,
    StableIdKeyProvider(recyclerView),
    MyDetailsLookup(recyclerView),
    StorageStrategy.createLongStorage())
        .withOnItemActivatedListener(myItemActivatedListener)
        .build()
</pre>
</section><section><h3 data-text="Java" id="java" tabindex="0">Java</h3>
<pre class="prettyprint lang-java" dir="ltr" translate="no">
SelectionTracker tracker = new SelectionTracker.Builder&lt;&gt;(
        "my-selection-id",
        recyclerView,
        new StableIdKeyProvider(recyclerView),
        new MyDetailsLookup(recyclerView),
        StorageStrategy.createLongStorage())
        .withOnItemActivatedListener(myItemActivatedListener)
        .build();
</pre>
</section></div>
</div>
<p>
  In order to build a
  <a href="/reference/androidx/recyclerview/selection/SelectionTracker"><code dir="ltr" translate="no">SelectionTracker</code></a>
  instance, your app must supply the same
  <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter">RecyclerView.Adapter</a></code> that you used to
  initialize <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView">RecyclerView</a></code>
  to
  <a href="/reference/androidx/recyclerview/selection/SelectionTracker.Builder"><code dir="ltr" translate="no">SelectionTracker.Builder</code></a>.
  For this reason, you will most likely need to inject the
  <a href="/reference/androidx/recyclerview/selection/SelectionTracker"><code dir="ltr" translate="no">SelectionTracker</code></a>
  instance, once created, into your
  <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter">RecyclerView.Adapter</a></code> after the
  <code dir="ltr" translate="no"><a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter">RecyclerView.Adapter</a></code>
  is
  created. Otherwise, you won't be able to check an item's selected status from
  the
  <a href="/reference/androidx/recyclerview/widget/RecyclerView.Adapter#onBindViewHolder(VH, int)"><code dir="ltr" translate="no">onBindViewHolder()</code></a>
  method.
</p>
<li>Include selection in the <a href="/guide/components/activities/activity-lifecycle">activity lifecycle</a>
    events.</li>
<p>In order to preserve selection state across the
    <a href="/guide/components/activities/activity-lifecycle">activity lifecycle</a>
    events, your app must call the selection tracker's
    <a href="/reference/androidx/recyclerview/selection/SelectionTracker#onSaveInstanceState(android.os.Bundle)"><code dir="ltr" translate="no">onSaveInstanceState()</code></a>
    and
    <a href="/reference/androidx/recyclerview/selection/SelectionTracker#onRestoreInstanceState(android.os.Bundle)"><code dir="ltr" translate="no">onRestoreInstanceState()</code></a>
    methods from the activity's
    <code dir="ltr" translate="no"><a href="/reference/android/app/Activity#onSaveInstanceState(android.os.Bundle)">onSaveInstanceState()</a></code> and
    <code dir="ltr" translate="no"><a href="/reference/android/app/Activity#onRestoreInstanceState(android.os.Bundle)">onRestoreInstanceState()</a></code>
    methods respectively. Your app must also supply a unique selection ID to the
    <a href="/reference/androidx/recyclerview/selection/SelectionTracker.Builder"><code dir="ltr" translate="no">SelectionTracker.Builder</code></a>
    constructor. This ID is required because an activity or a fragment may have
    more than one distinct, selectable list, all of which need to be persisted
    in their saved state.
</p>
<h2 data-text="Additional resources" id="additional-resources" tabindex="0">Additional resources</h2>
<p><code dir="ltr" translate="no">RecyclerView</code> is
used in the <a href="https://github.com/googlesamples/android-sunflower">Sunflower</a> demo app.</p>
</ol></div>
        </div>
    </div>


            
    {%if length != 0 %}

    {%for i in range(length)%}
    <div class="result-component">
        <h3>{{selectedTitle[i]}}</h3>
        <a href="{{selectedLink[i]}}" target="_blank">{{selectedLink[i]}}</a>
        <div class="content">
            {{html[i]}}
        </div>
    </div>
    {%endfor%}

{%else%}
    <img class="robo-img" src="./static/image/search.png" alt="seaching minions image ">
{%endif%}


</div>
</body>
</html>